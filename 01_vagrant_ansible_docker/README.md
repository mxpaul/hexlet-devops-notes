# Почему ansible подходит для  vagrant и не подходит для docker

Здесь попытаемся ответить на вопрос почему применение ansible для vagrant-окружений с Virtualbox
считается правильным, а в Dockerfile мы обычно записываем shell-команды, хотя казалось бы, тех
же результатов можно добиться через ansible

Главная особенность в том что из Dockerfile мы собираем образ. Этот образ собирается один раз и 
потом не меняется (пока нам не понадобится новая версия). Из одного образа может запуститься 
бесконечное число контейнеров на разных машинах. И все они могут быть кастомизированы. В том 
смысле что образ служит основой для файловой системы контейнера, на которую сверху могут 
накладываться другие слои (если от образа отнаследовались в другом Dockerfile-е, например). На 
образ сверху могут монтироваться тома (volume) и overlay который позволяет процессам внутри 
контейнера осуществлять запись в файловую систему, при этом не внося изменения в исходный образ.

И все это происходит на стадии запуска контейнера. А из Dockerfile, повторюсь, мы собираем только
образ. Образ этот потом заливается в docker registry и лежит там пока кому-нибудь не понадобится.
Вот когда кто-то захочет из этого образа запустить контейнер, он его стянет из registry на свою
машину, и там запустит. Случай когда мы собрали образ из Dockerfile и тут же запустили на своей
машине - частный, это сути не меняет.

Отсюда, из факта путешествия нашего ~~хоббита~~ образа туда (registry) и обратно, следует наше 
желание сделать размер образа как можно меньше. Иначе нам придется долго ждать скачивания по сети,
сеть ведь не резиновая. Минимализация образа достигается за счет выкидывания из него всего чего
только возможно. В docker ведь не просто так существует концепция `один контейнер = один процесс`.
Это в том числе позволяет не держать в образе того, что не понадобится для запуска нашего процесса.

Если уж проводить аналогию между docker и vagrant, то docker image это аналог vagrant box. И его 
(box) тоже обычно через ansible и прочие Content Management System-ы не собирают. Ansible запускают 
уже на приготовленной виртуалке. Это как контейнер в докере, следуя нашей аналогии.

ansible, кстати, хорош именно для поддержания состояния. То есть у нас есть определенный результат, 
который мы описываем в плейбуке, а задача ansible проанализировать конкретную систему и если что-то
в ней описанному результату не соответствует, сделать так чтобы соответствовало. Здесь и кроется 
одна из причин по которым ansible в Dockerfile не используют. Образ не должен меняться, его надо 
один раз сделать, и после этого следить за состоянием больше не нужно.

Вторая причина - размер образа. Мы уже выяснили что размер имеет значение, и в случае с докером
чем меньше размер образа, тем лучше. Если мы начнем в него тащить ansible, который, напомню, 
написан на питоне, в образ приедет много лишнего. И даже если мы отрежем это лишнее через FROM,
мы все равно чаще всего наследуемся от какого-то чужого образа, который тоже уже минимизировали
по полной, и в который ansible придется сначала поставить, потом использовать, потом отрезать.
Это может быть просто долго, по той же сети мы начнем гонять ansible на каждый запуск docker 
build, что тоже наших пользователей моложе не делает.

Главная же причина по которой мы не хотим использовать ansible и аналоги в Dockerfile скрывается 
в слоях. Каждая команда в Dockerfile-е создает слой, и этот слой может быть закеширован. В том 
числе он может храниться в registry в виде образа (как исходный слой), то есть он занимает какое-то
место. Результат сборки образа это результат последовательного наложения друг на друга всех слоев
из которых он состоит. При частой пересборке образа мы можем захотеть кешировать (и docker 
действительно кеширует) собранные ранее слои. То есть если команда, например, в RUN не поменялась,
докер может считать что результат ее работы с точки зрения получившегося слоя будет точно таким
как и в прошлый проход. Поэтому команду можно не выполнять, а взять результат прошлого запуска
который лежит у нас где-то на диске. Если же docker build видит что с прошлого запуска Dockerfile
поменялся (не побайтно, а по командам), то новую команду он честно выполнит, и результат тоже 
где-то на диске закеширует для следующего раза.

Проблема тут в том что результат запуска `apt install -y make` достаточно предсказуем, а вот 
результат запуска ansible-playbook при одной и той же команде может быть разным в зависимости 
от плейбука, от исходного состояния, от режима запуска, вплоть до имен (динамически изменяемых)
временных файлов в которые он складывает шаблоны прежде чем их накатить в систему. Опять же, в 
целях кеширования мы можем захотеть какие-то файлы записывать в один слой (чем реже меняется файл, 
тем раньше в последовательности команд), а какие-то в последующий. Один из примеров - копирование
package.json для nodejs-проектов. В ansible если уж у нас есть роль, и даже чаще несколько ролей,
они накатятся в одном плейбуке и попадут в один слой.

Вот так и получается что использование ansible в Dockerfile-ах плохая идея. Для виртуалок же, 
созданных в вагранте один раз и далее живущих своей жизнью, ansible оказывается очень удобен,
и поэтому широко используется. Здесь все его преимущества не обесцениваются благодаря более 
демократичной постановки задачи. Это еще раз напоминает нам о том что каждый инструмент хорош
на своем месте, а пихать модную штуку во все места потому что "в интернете штука очень популярная"
неправильно.


